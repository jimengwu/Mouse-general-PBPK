DLC_Lung = 0.001,
DLC_Rest = 0.000001,
Kbile = 0.00003,       # Biliary clearance (L/hr)
Kurine = 0.000003,     # Urine clearance (L/hr)
sig2                  = 0.5, ## Model error (residuals);
## mostly between 0.3 and 0.5 (corresponding to
## coefficients of variation of about 30-50%); Bois et al. (1998, 2000)
## population variance; equal to the CV of parameters (this study assued the cv of all parametesr is 0.3)
sig_K_release_Liver = 0.3,  # h-1
sig_K_max_Liver = 0.3,         # h-1
sig_K_50_Liver = 0.3,          # h
sig_n_Liver = 0.3,              # Unitless
sig_K_release_Spleen = 0.3, # h-1
sig_K_max_Spleen = 0.3,        # h-1
sig_K_50_Spleen = 0.3,
sig_n_Spleen = 0.3,
sig_K_release_Kidney = 0.3, # h-1
sig_K_max_Kidney = 0.3,
sig_K_50_Kidney = 0.3,
sig_n_Kidney = 0.3,
sig_K_release_Lung = 0.3,   # h-1
sig_K_max_Lung = 0.3,
sig_K_50_Lung = 0.3,
sig_n_Lung = 0.3,
sig_P_Liver  = 0.3,
sig_P_Brain  = 0.3,
sig_P_Kidney  = 0.3,
sig_P_Spleen  = 0.3,
sig_P_Lung  = 0.3,
sig_P_Rest  = 0.3,
sig_DLC_Liver = 0.3,
sig_DLC_Brain = 0.3,
sig_DLC_Kidney = 0.3,
sig_DLC_Spleen = 0.3,
sig_DLC_Lung = 0.3,
sig_DLC_Rest = 0.3,
sig_Kbile = 0.3,       # Biliary clearance (L/hr)
sig_Kurine = 0.3     # Urine clearance (L/hr)
))
#--------------Maximum likelihood estimation (MLE) function for MCMC----
mcmc.fun <- function (pars, pred=FALSE){
## Get out of log domain
pars.data <- lapply(pars [-which_sig],exp)
# Exposure scenario for single oral dose of 20 mg/kg
BW                    = 0.025                            ## kg, Mice body weight
tinterval             = 24                               ## hr, Time interval
TDoses                = 1                                ## Dose times
PDOSEoral.B           = 20                               ## mg/kg-d, Single oral dose
DOSEoral.B            = PDOSEoral.B*BW                   ## mg, amount of oral dose
ex.oral.B<- ev(ID=1,
amt= DOSEoral.B,
ii=tinterval,
addl=TDoses-1,
cmt="MBV",
replicate = FALSE)
## set up the exposure time
tsamp=tgrid(0,tinterval*(TDoses-1)+24*200,1)             ## simulation time 24*200 hr (200 days)
## Get a prediction
out.B <-
mod %>%
param(pars.data) %>%
Req(Plasma, Liver, Kidney, Aurine, Afeces)%>%
update(atol = 1E-8, maxsteps= 5000) %>%
mrgsim_d(data = ex.oral.B, tgrid=tsamp)
out.B = cbind.data.frame(Time   = out.B$time/24,
CL=out$Liver_t,
CK = out$Kidney_t,
CS = out$Spleen_t,
CB= out$Brain_t,
Clung = out$Lung_t)
if (pred) return (out.B)
out.B = outdf[which(out.B$Time %in% Obs.B1$Time),]
## log-transformed prediction
log.yhat.CL     <- log(out.B$CL)
log.yhat.CK     <- log(out.B$CK)
## log-transformed experimental data
log.y.CL        <- log(Obs.B2$CL)
log.y.CK        <- log(Obs.B3$CK)
## The method of Maximum likelihood
log.yhat        <- c(log.yhat.CL,log.yhat.CK)
log.y           <- c(log.y.CL,log.y.CK)
sig2            <- as.numeric((exp(pars[which_sig][1])))
log_likelihood  <- -2*sum((dnorm (log.y,
mean = log.yhat,
sd   = sqrt(sig2),
log=TRUE)))
return(log_likelihood)
}
## Define the Prior distributions: either normal or log normal distribution
## normal distribution
## normal distribution
Prior <- function(pars) {
## Population level
# The likelihood for population mean (parameters)
pars.data = exp(pars[-which_sig])
sig  <- as.numeric (exp(pars[which_sig][2:18]))                 # Coefficient of variation from population variance; sigmal0
sig2 <- as.numeric (exp(pars[which_sig][1]))                    # error variances from model residual
mean           = exp(theta.MCMC[-which_sig])
CV             = 0.5                                            # Coefficient of variation; Default value of 0.5 in all parameters (Bois,2000; Bois et al., 1996)
sd             = mean*CV
# Calculate likelihoods of each parameters; P(u|M,S)
prior_pars     = dtruncnorm(pars.data,
a = qnorm(0.025, mean = mean, sd = sd),
b = qnorm(0.975, mean = mean, sd = sd),
mean = mean, sd = sd )
# The likelihood for population variance; P(sigmal^2|sigmal0^2)
CU             = 1                                              # Coefficient of uncertainty (CU) (Hack et al., 2006)
CV.sig         = exp(theta.MCMC[which_sig])[2:18]               # Singmal0
alpha          = (2+1)/(CU^2)                                   # Shape parametrer of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
beta           = (alpha-1)*CV.sig^2                             # Scale parameter  of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
# Calculate likelihoods of model error (sig2) and population variance (sig) parameters
prior_sig      = dinvgamma (sig, shape = alpha , scale = beta)  # prior distribution for population vraicne; sigma2
prior_sig2     = dunif (sig2, min = 0.01, max = 3.3)            # error variances, Lower and upper boundary from Chiu et al., 2009; Chiu et al., 2014)
## individual level; P(theta|u,sigmal^2)
mean_i         = prior_pars
sd_i           = sqrt(prior_sig)
prior_pars_i   = dtruncnorm (prior_pars,
a = qnorm(0.025, mean = mean_i, sd = sd_i),
b = qnorm(0.975, mean = mean_i, sd = sd_i),
mean = mean_i, sd = sd_i)
# log-transformed (log-likelihoods of each parameters)
log.pri.pars   = log (prior_pars)
log.pri.sig    = log (prior_sig)
log.pri.pars.i = log (prior_pars_i)
log.pri.sig2   = log (prior_sig2)
# maximau likelihood estimation (MLE): negative log-likelihood function, (-2 times sum of log-likelihoods)
MLE =  -2*sum(log.pri.pars, log.pri.sig , log.pri.pars.i,log.pri.sig2)
return(MLE)
}
#################### 5. MCMC simulation with parallel computing ############################
detectCores()                                ## check the cores
cl<- makeCluster(detectCores())              ## use all cores in our system
registerDoParallel(cl)                       ## registers a cluster of all the cores on our system
# start time
strt<-Sys.time()
# parallel
system.time(
MCMC <- foreach( i = 1:4, .packages = c('mrgsolve','magrittr','FME',
'truncnorm','EnvStats',
'invgamma','dplyr')) %dopar% {
mod <- mcode ("micepbpk", micePBPK.code)
modMCMC(f             = mcmc.fun,
p             = theta.MCMC,
niter         = 500000,           ## iteration number
jump          = 0.01,             ## jump function generation new parameters distribution using covrate matrix
prior         = Prior,            ## prior function
updatecov     = 50,               ## adaptive Metropolis
var0          = NULL,             ## initial model variance;
wvar0         = 0.01,             ## "weight" for the initial model variance
ntrydr        = 2,                ## delayed Rejection
burninlength  = 250000,           ## number of initial iterations to be removed from output.
outputlength  = 50000)            ## number of output iterations
}
)
# parallel
system.time(
MCMC <- foreach( i = 1:4, .packages = c('mrgsolve','magrittr','FME',
'truncnorm','EnvStats',
'invgamma','dplyr')) %dopar% {
mod <- mcode ("micepbpk", mousePBPK.code)
modMCMC(f             = mcmc.fun,
p             = theta.MCMC,
niter         = 500000,           ## iteration number
jump          = 0.01,             ## jump function generation new parameters distribution using covrate matrix
prior         = Prior,            ## prior function
updatecov     = 50,               ## adaptive Metropolis
var0          = NULL,             ## initial model variance;
wvar0         = 0.01,             ## "weight" for the initial model variance
ntrydr        = 2,                ## delayed Rejection
burninlength  = 250000,           ## number of initial iterations to be removed from output.
outputlength  = 50000)            ## number of output iterations
}
)
#--------------Maximum likelihood estimation (MLE) function for MCMC----
mcmc.fun <- function (pars, pred=FALSE){
## Get out of log domain
pars.data <- lapply(pars [-which_sig],exp)
# Exposure scenario for single oral dose of 20 mg/kg
BW                    = 0.025                            ## kg, Mice body weight
tinterval             = 24                               ## hr, Time interval
TDoses                = 1                                ## Dose times
PDOSEoral.B           = 20                               ## mg/kg-d, Single oral dose
DOSEoral.B            = PDOSEoral.B*BW                   ## mg, amount of oral dose
ex.oral.B<- ev(ID=1,
amt= DOSEoral.B,
ii=tinterval,
addl=TDoses-1,
cmt="MBV",
replicate = FALSE)
## set up the exposure time
tsamp=tgrid(0,tinterval*(TDoses-1)+24*200,1)             ## simulation time 24*200 hr (200 days)
## Get a prediction
out.B <-
mod %>%
param(pars.data) %>%
Req(Plasma, Liver, Kidney, Aurine, Afeces)%>%
update(atol = 1E-8, maxsteps= 5000) %>%
mrgsim_d(data = ex.oral.B, tgrid=tsamp)
out.B = cbind.data.frame(Time   = out.B$time/24,
CL=out$Liver_t,
CK = out$Kidney_t,
CS = out$Spleen_t,
CB= out$Brain_t,
Clung = out$Lung_t)
if (pred) return (out.B)
out.B = outdf[which(out.B$Time %in% Obs.B1$Time),]
## log-transformed prediction
log.yhat.CL     <- log(out.B$CL)
log.yhat.CK     <- log(out.B$CK)
## log-transformed experimental data
log.y.CL        <- log(Obs.A2$CL)
log.y.CK        <- log(Obs.A2$CK)
## The method of Maximum likelihood
log.yhat        <- c(log.yhat.CL,log.yhat.CK)
log.y           <- c(log.y.CL,log.y.CK)
sig2            <- as.numeric((exp(pars[which_sig][1])))
log_likelihood  <- -2*sum((dnorm (log.y,
mean = log.yhat,
sd   = sqrt(sig2),
log=TRUE)))
return(log_likelihood)
}
## Define the Prior distributions: either normal or log normal distribution
## normal distribution
## normal distribution
Prior <- function(pars) {
## Population level
# The likelihood for population mean (parameters)
pars.data = exp(pars[-which_sig])
sig  <- as.numeric (exp(pars[which_sig][2:18]))                 # Coefficient of variation from population variance; sigmal0
sig2 <- as.numeric (exp(pars[which_sig][1]))                    # error variances from model residual
mean           = exp(theta.MCMC[-which_sig])
CV             = 0.5                                            # Coefficient of variation; Default value of 0.5 in all parameters (Bois,2000; Bois et al., 1996)
sd             = mean*CV
# Calculate likelihoods of each parameters; P(u|M,S)
prior_pars     = dtruncnorm(pars.data,
a = qnorm(0.025, mean = mean, sd = sd),
b = qnorm(0.975, mean = mean, sd = sd),
mean = mean, sd = sd )
# The likelihood for population variance; P(sigmal^2|sigmal0^2)
CU             = 1                                              # Coefficient of uncertainty (CU) (Hack et al., 2006)
CV.sig         = exp(theta.MCMC[which_sig])[2:18]               # Singmal0
alpha          = (2+1)/(CU^2)                                   # Shape parametrer of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
beta           = (alpha-1)*CV.sig^2                             # Scale parameter  of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
# Calculate likelihoods of model error (sig2) and population variance (sig) parameters
prior_sig      = dinvgamma (sig, shape = alpha , scale = beta)  # prior distribution for population vraicne; sigma2
prior_sig2     = dunif (sig2, min = 0.01, max = 3.3)            # error variances, Lower and upper boundary from Chiu et al., 2009; Chiu et al., 2014)
## individual level; P(theta|u,sigmal^2)
mean_i         = prior_pars
sd_i           = sqrt(prior_sig)
prior_pars_i   = dtruncnorm (prior_pars,
a = qnorm(0.025, mean = mean_i, sd = sd_i),
b = qnorm(0.975, mean = mean_i, sd = sd_i),
mean = mean_i, sd = sd_i)
# log-transformed (log-likelihoods of each parameters)
log.pri.pars   = log (prior_pars)
log.pri.sig    = log (prior_sig)
log.pri.pars.i = log (prior_pars_i)
log.pri.sig2   = log (prior_sig2)
# maximau likelihood estimation (MLE): negative log-likelihood function, (-2 times sum of log-likelihoods)
MLE =  -2*sum(log.pri.pars, log.pri.sig , log.pri.pars.i,log.pri.sig2)
return(MLE)
}
#################### 5. MCMC simulation with parallel computing ############################
detectCores()                                ## check the cores
cl<- makeCluster(detectCores())              ## use all cores in our system
registerDoParallel(cl)                       ## registers a cluster of all the cores on our system
# start time
strt<-Sys.time()
# parallel
system.time(
MCMC <- foreach( i = 1:4, .packages = c('mrgsolve','magrittr','FME',
'truncnorm','EnvStats',
'invgamma','dplyr')) %dopar% {
mod <- mcode ("micepbpk", mousePBPK.code)
modMCMC(f             = mcmc.fun,
p             = theta.MCMC,
niter         = 500000,           ## iteration number
jump          = 0.01,             ## jump function generation new parameters distribution using covrate matrix
prior         = Prior,            ## prior function
updatecov     = 50,               ## adaptive Metropolis
var0          = NULL,             ## initial model variance;
wvar0         = 0.01,             ## "weight" for the initial model variance
ntrydr        = 2,                ## delayed Rejection
burninlength  = 250000,           ## number of initial iterations to be removed from output.
outputlength  = 50000)            ## number of output iterations
}
)
warnings()
#--------------Maximum likelihood estimation (MLE) function for MCMC----
mcmc.fun <- function (pars, pred=FALSE){
## Get out of log domain
pars.data <- lapply(pars [-which_sig],exp)
# Exposure scenario for single oral dose of 0.85 mg/kg
BW           = 0.02                              ## kg, body weight
tinterval    = 1                                 ## hr, Time interval
TDoses       = 1                                 ## Dose times, only one dose
PDOSE        = 0.85                              ## mg/kg-day, Single dose
DOSE         = PDOSE*BW                          ## mg, amount of iv dose
ex.iv<- ev(ID=1, amt= DOSE,                  ## Set up the exposure events
ii=tinterval, addl=TDoses-1,
cmt="MBV", replicate = FALSE)
## set up the exposure time
tsamp=tgrid(0,tinterval*(TDoses-1)+24*7,1)     ## Simulation time 24*180 hours (180 days)
## Get a prediction
out <-
mod %>%
param(pars.data) %>%
update(atol = 1E-8, maxsteps= 5000) %>%
mrgsim_d(data = ex.iv, tgrid=tsamp)
out <- data.frame(Time=out$time,
CL=out$Liver_t,
CK = out$Kidney_t,
CS = out$Spleen_t,
CB= out$Brain_t,
Clung = out$Lung_t)
if (pred) return (out)
out = outdf[which(out$Time %in% Obs.A2$Time),]
## log-transformed prediction
log.yhat.CL     <- log(out$CL)
log.yhat.CK     <- log(out$CK)
## log-transformed experimental data
log.y.CL        <- log(Obs.A2$CL)
log.y.CK        <- log(Obs.A2$CK)
## The method of Maximum likelihood
log.yhat        <- c(log.yhat.CL,log.yhat.CK)
log.y           <- c(log.y.CL,log.y.CK)
sig2            <- as.numeric((exp(pars[which_sig][1])))
log_likelihood  <- -2*sum((dnorm (log.y,
mean = log.yhat,
sd   = sqrt(sig2),
log=TRUE)))
return(log_likelihood)
}
## Define the Prior distributions: either normal or log normal distribution
## normal distribution
## normal distribution
Prior <- function(pars) {
## Population level
# The likelihood for population mean (parameters)
pars.data = exp(pars[-which_sig])
sig  <- as.numeric (exp(pars[which_sig][2:18]))                 # Coefficient of variation from population variance; sigmal0
sig2 <- as.numeric (exp(pars[which_sig][1]))                    # error variances from model residual
mean           = exp(theta.MCMC[-which_sig])
CV             = 0.5                                            # Coefficient of variation; Default value of 0.5 in all parameters (Bois,2000; Bois et al., 1996)
sd             = mean*CV
# Calculate likelihoods of each parameters; P(u|M,S)
prior_pars     = dtruncnorm(pars.data,
a = qnorm(0.025, mean = mean, sd = sd),
b = qnorm(0.975, mean = mean, sd = sd),
mean = mean, sd = sd )
# The likelihood for population variance; P(sigmal^2|sigmal0^2)
CU             = 1                                              # Coefficient of uncertainty (CU) (Hack et al., 2006)
CV.sig         = exp(theta.MCMC[which_sig])[2:18]               # Singmal0
alpha          = (2+1)/(CU^2)                                   # Shape parametrer of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
beta           = (alpha-1)*CV.sig^2                             # Scale parameter  of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
# Calculate likelihoods of model error (sig2) and population variance (sig) parameters
prior_sig      = dinvgamma (sig, shape = alpha , scale = beta)  # prior distribution for population vraicne; sigma2
prior_sig2     = dunif (sig2, min = 0.01, max = 3.3)            # error variances, Lower and upper boundary from Chiu et al., 2009; Chiu et al., 2014)
## individual level; P(theta|u,sigmal^2)
mean_i         = prior_pars
sd_i           = sqrt(prior_sig)
prior_pars_i   = dtruncnorm (prior_pars,
a = qnorm(0.025, mean = mean_i, sd = sd_i),
b = qnorm(0.975, mean = mean_i, sd = sd_i),
mean = mean_i, sd = sd_i)
# log-transformed (log-likelihoods of each parameters)
log.pri.pars   = log (prior_pars)
log.pri.sig    = log (prior_sig)
log.pri.pars.i = log (prior_pars_i)
log.pri.sig2   = log (prior_sig2)
# maximau likelihood estimation (MLE): negative log-likelihood function, (-2 times sum of log-likelihoods)
MLE =  -2*sum(log.pri.pars, log.pri.sig , log.pri.pars.i,log.pri.sig2)
return(MLE)
}
#################### 5. MCMC simulation with parallel computing ############################
detectCores()                                ## check the cores
cl<- makeCluster(detectCores())              ## use all cores in our system
registerDoParallel(cl)                       ## registers a cluster of all the cores on our system
# start time
strt<-Sys.time()
# parallel
system.time(
MCMC <- foreach( i = 1:4, .packages = c('mrgsolve','magrittr','FME',
'truncnorm','EnvStats',
'invgamma','dplyr')) %dopar% {
mod <- mcode ("micepbpk", mousePBPK.code)
modMCMC(f             = mcmc.fun,
p             = theta.MCMC,
niter         = 500000,           ## iteration number
jump          = 0.01,             ## jump function generation new parameters distribution using covrate matrix
prior         = Prior,            ## prior function
updatecov     = 50,               ## adaptive Metropolis
var0          = NULL,             ## initial model variance;
wvar0         = 0.01,             ## "weight" for the initial model variance
ntrydr        = 2,                ## delayed Rejection
burninlength  = 250000,           ## number of initial iterations to be removed from output.
outputlength  = 50000)            ## number of output iterations
}
)
out = out[which(out$Time %in% Obs.A2$Time),]
#--------------Maximum likelihood estimation (MLE) function for MCMC----
mcmc.fun <- function (pars, pred=FALSE){
## Get out of log domain
pars.data <- lapply(pars [-which_sig],exp)
# Exposure scenario for single oral dose of 0.85 mg/kg
BW           = 0.02                              ## kg, body weight
tinterval    = 1                                 ## hr, Time interval
TDoses       = 1                                 ## Dose times, only one dose
PDOSE        = 0.85                              ## mg/kg-day, Single dose
DOSE         = PDOSE*BW                          ## mg, amount of iv dose
ex.iv<- ev(ID=1, amt= DOSE,                  ## Set up the exposure events
ii=tinterval, addl=TDoses-1,
cmt="MBV", replicate = FALSE)
## set up the exposure time
tsamp=tgrid(0,tinterval*(TDoses-1)+24*7,1)     ## Simulation time 24*180 hours (180 days)
## Get a prediction
out <-
mod %>%
param(pars.data) %>%
update(atol = 1E-8, maxsteps= 5000) %>%
mrgsim_d(data = ex.iv, tgrid=tsamp)
out <- data.frame(Time=out$time,
CL=out$Liver_t,
CK = out$Kidney_t,
CS = out$Spleen_t,
CB= out$Brain_t,
Clung = out$Lung_t)
if (pred) return (out)
out = out[which(out$Time %in% Obs.A2$Time),]
## log-transformed prediction
log.yhat.CL     <- log(out$CL)
log.yhat.CK     <- log(out$CK)
## log-transformed experimental data
log.y.CL        <- log(Obs.A2$CL)
log.y.CK        <- log(Obs.A2$CK)
## The method of Maximum likelihood
log.yhat        <- c(log.yhat.CL,log.yhat.CK)
log.y           <- c(log.y.CL,log.y.CK)
sig2            <- as.numeric((exp(pars[which_sig][1])))
log_likelihood  <- -2*sum((dnorm (log.y,
mean = log.yhat,
sd   = sqrt(sig2),
log=TRUE)))
return(log_likelihood)
}
## Define the Prior distributions: either normal or log normal distribution
## normal distribution
## normal distribution
Prior <- function(pars) {
## Population level
# The likelihood for population mean (parameters)
pars.data = exp(pars[-which_sig])
sig  <- as.numeric (exp(pars[which_sig][2:18]))                 # Coefficient of variation from population variance; sigmal0
sig2 <- as.numeric (exp(pars[which_sig][1]))                    # error variances from model residual
mean           = exp(theta.MCMC[-which_sig])
CV             = 0.5                                            # Coefficient of variation; Default value of 0.5 in all parameters (Bois,2000; Bois et al., 1996)
sd             = mean*CV
# Calculate likelihoods of each parameters; P(u|M,S)
prior_pars     = dtruncnorm(pars.data,
a = qnorm(0.025, mean = mean, sd = sd),
b = qnorm(0.975, mean = mean, sd = sd),
mean = mean, sd = sd )
# The likelihood for population variance; P(sigmal^2|sigmal0^2)
CU             = 1                                              # Coefficient of uncertainty (CU) (Hack et al., 2006)
CV.sig         = exp(theta.MCMC[which_sig])[2:18]               # Singmal0
alpha          = (2+1)/(CU^2)                                   # Shape parametrer of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
beta           = (alpha-1)*CV.sig^2                             # Scale parameter  of gamma distribution; Appendix Table A-7 from EPA (2011) :EPA/635/R-09/011F
# Calculate likelihoods of model error (sig2) and population variance (sig) parameters
prior_sig      = dinvgamma (sig, shape = alpha , scale = beta)  # prior distribution for population vraicne; sigma2
prior_sig2     = dunif (sig2, min = 0.01, max = 3.3)            # error variances, Lower and upper boundary from Chiu et al., 2009; Chiu et al., 2014)
## individual level; P(theta|u,sigmal^2)
mean_i         = prior_pars
sd_i           = sqrt(prior_sig)
prior_pars_i   = dtruncnorm (prior_pars,
a = qnorm(0.025, mean = mean_i, sd = sd_i),
b = qnorm(0.975, mean = mean_i, sd = sd_i),
mean = mean_i, sd = sd_i)
# log-transformed (log-likelihoods of each parameters)
log.pri.pars   = log (prior_pars)
log.pri.sig    = log (prior_sig)
log.pri.pars.i = log (prior_pars_i)
log.pri.sig2   = log (prior_sig2)
# maximau likelihood estimation (MLE): negative log-likelihood function, (-2 times sum of log-likelihoods)
MLE =  -2*sum(log.pri.pars, log.pri.sig , log.pri.pars.i,log.pri.sig2)
return(MLE)
}
#################### 5. MCMC simulation with parallel computing ############################
detectCores()                                ## check the cores
cl<- makeCluster(detectCores())              ## use all cores in our system
registerDoParallel(cl)                       ## registers a cluster of all the cores on our system
# start time
strt<-Sys.time()
# parallel
system.time(
MCMC <- foreach( i = 1:4, .packages = c('mrgsolve','magrittr','FME',
'truncnorm','EnvStats',
'invgamma','dplyr')) %dopar% {
mod <- mcode ("micepbpk", mousePBPK.code)
modMCMC(f             = mcmc.fun,
p             = theta.MCMC,
niter         = 500000,           ## iteration number
jump          = 0.01,             ## jump function generation new parameters distribution using covrate matrix
prior         = Prior,            ## prior function
updatecov     = 50,               ## adaptive Metropolis
var0          = NULL,             ## initial model variance;
wvar0         = 0.01,             ## "weight" for the initial model variance
ntrydr        = 2,                ## delayed Rejection
burninlength  = 250000,           ## number of initial iterations to be removed from output.
outputlength  = 50000)            ## number of output iterations
}
)
